/**
 *                          EE 599 Final Project
 *                  Yao Guo, Yang Zhang and Weichang Wang
 *
 * A Cambricon ISA compiler which reads a low-level IR file generated by a neural
 * network program. The low-level IR is optimized by Glow compiler to perform
 * fast training process. This Cambricon compiler further compiles IR to Cambricon
 * ISA which support several useful machine learning instructions. The ISA file
 * can be apply to the Cambricon hardware to perform a hardware-accelerated
 * machine learning process.
 *
 */

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <deque>
#include <map>
#include <regex>
#include <sstream>

#include "Function.h"

using namespace std;

void compileInit();

void convertCode(string line, vector<string> &vec);

string findVarName(string &line);

string findType(string &line);

vector<string> findSize(string &line);

string findFuncName(string &line);

string findFuncOut(string &line);

void findFuncIn(string &line, vector<Variable *> &vec);

vector<string> split(const string &stringToBeSplitted, const string &delimeter);

bool declareLine(string &line);

bool deallocLine(string &line);

string findDealloc(const string &line);

void printISA(char *outFileName, vector<string> &vec);

void print_vector(deque<string> a);

deque<string> split(const string &s);

map<string, Variable> mapVar;

deque<string> regDeque;

int main(int argc, char *argv[]) {
    // Check command line arguments
    if (argc != 3) {
        cerr << "Usage: ./executable <input> <output>" << endl;
        return -1;
    }

    // Read input file
    ifstream inFile;
    inFile.open(argv[1]);
    if (!inFile) {
        cerr << "Failed to open file " << argv[1] << endl;
        return -1;
    }

    compileInit();

    string declare_line;
    getline(inFile, declare_line);
    while (getline(inFile, declare_line)) {
        size_t found = declare_line.find("; size");
        if (found != string::npos)
            break;
        deque<string> token;
        token = split(declare_line);
        int len = token.size();
        // if return a empty token break
        if (!token.empty()) {
            int num_of_number = token.size() - 4;
            string d1 = token[0];//input
            string d2 = token[1];//weightVar
            string d3 = token[2];//float

            //print_vector(token);

            vector<int> dimension(5, 0);
            int n = 0;
            for (int i = 3; i < token.size() - 1; i++) {
                dimension[n] = atoi(token[i].c_str());
                n += 1;
            }
            // Construct the variable and push to global vector
            string assignReg = regDeque[0];
            Variable v(d1, d3, assignReg, dimension);
            regDeque.pop_front();
            mapVar.insert(pair<string, Variable>(d1, v));
            vector<int>::iterator it;
            for (it = dimension.begin(); it != dimension.end(); ++it) {
                // cout << *it <<" ";
            }
            // cout << endl;
        }
    }

    // Find the line contains the real low-level IR code
    string line;
    while (getline(inFile, line)) {
        size_t found = line.find("code {");
        if (found != string::npos)
            break;
    }
    // Can't find code part till end of file
    if (!inFile) {
        cerr << "Input file is not in a proper format" << endl;
        return -1;
    }

    // Read every line and generate ISA accordingly
    vector<string> vecISA;
    while (getline(inFile, line)) {
        if (line == "}")
            break;
        convertCode(line, vecISA);
    }
    inFile.close();
    printISA(argv[2], vecISA);

    return 0;
}

/**
 * Initialize the data structures for compiler
 */
void compileInit() {
    for (int i = 0; i < MAX_REG_NUM; i++) {
        string regName = '$' + to_string(i);
        regDeque.push_back(regName);
    }
}

/**
 * Convert current line to an object
 * @param line
 * @param vec
 */
void convertCode(string line, vector<string> &vec) {
    string var = findVarName(line);

    // If the line is only a declaration
    if (declareLine(line)) {
        string varType = findType(line);
        vector<string> vecSize = findSize(line);
        // Construct a Variable type object
        vector<int> vecSizeInt(5, 0);
        for (int i = 0; i < vecSize.size(); i++) {
            vecSizeInt[i] = stoi(vecSize[i]);
        }
        string assignReg = regDeque[0];
        Variable v(var, varType, assignReg, vecSizeInt);
        regDeque.pop_front();
        mapVar.insert(pair<string, Variable>(var, v));

    } else if (deallocLine(line)) { // A dealloc line
        string varName = findDealloc(line);
        auto it = mapVar.find(varName);
        Variable varDealloc = it->second;
        // Delete the reg and variable in the global deque and map
        regDeque.push_back(varDealloc.getRegister());
        mapVar.erase(it);

    } else { // A function line
        string funcName = findFuncName(line);
        string outName = findFuncOut(line);
        vector<Variable *> inName;
        findFuncIn(line, inName);
        string assignReg = regDeque[0];
        auto it = mapVar.find(outName);
        Variable *varPtr = nullptr;
        if (it != mapVar.end()) {
            varPtr = &(it->second);
        }
        Function f(var, assignReg, funcName, varPtr, inName);
        regDeque.pop_front();
        vec.push_back(f.process());
    }
}

/**
 * Find functions to parse the complicated line
 * @param line will be parsed
 * @return variable
 */
string findVarName(string &line) {
    size_t varStart = line.find('%') + 1;
    size_t varEnd = line.find(" =");
    string var = line.substr(varStart, varEnd - varStart);
    line = line.substr(varEnd + 3);
    return var;
}

string findType(string &line) {
    size_t varStart = line.find("Ty: ") + 4;
    size_t varEnd = line.find('<');
    string var = line.substr(varStart, varEnd - varStart);
    return var;
}

vector<string> findSize(string &line) {
    size_t varStart = line.find('<') + 1;
    size_t varEnd = line.find('>');
    string var = line.substr(varStart, varEnd - varStart);
    vector<string> vec = split(var, " x ");
    return vec;
}

string findDealloc(const string &line) {
    size_t varStart = line.find("@out") + 6;
    size_t varEnd = line.find(" //");
    string var = line.substr(varStart, varEnd - varStart);
    return var;
}

string findFuncName(string &line) {
    size_t nameStart = 0;
    size_t nameEnd = line.find(" @");
    string name = line.substr(nameStart, nameEnd - nameStart);
    return name;
}

string findFuncOut(string &line) {
    size_t outStart = line.find("@out");
    if (outStart == string::npos)
        return "None";
    outStart += 6;
    size_t outEnd = line.find(", @in");
    string out = line.substr(outStart, outEnd - outStart);
    line = line.substr(outEnd + 2);
    return out;
}

void findFuncIn(string &line, vector<Variable *> &vec) {
    size_t inStart;
    while ((inStart = line.find("@in")) != string::npos) {
        inStart += 5;
        size_t inEnd = line.find(", @in");
        if (inEnd == string::npos)
            inEnd = line.find(" {");
        string in = line.substr(inStart, inEnd - inStart);
        Variable *inPtr;
        auto it = mapVar.find(in);
        inPtr = &(it->second);
        vec.push_back(inPtr);
        line = line.substr(inEnd + 2);
    }
}

/**
 * Check if this is a declaration line
 * @param line
 * @return true if it is
 */
bool declareLine(string &line) {
    if ((line.find("allocactivation") != string::npos)
        && (line.find("deallocactivation") == string::npos)) {
        return true;
    }
    return false;
}

bool deallocLine(string &line) {
    if (line.find("deallocactivation") != string::npos) {
        return true;
    }
    return false;
}

/**
 * Split the line by delimiter
 * Reference: https://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/
 * @param s
 * @param delimiter
 * @return split vector of tokens
 */
vector<string> split(const string &stringToBeSplitted, const string &delimeter) {
    vector<string> splittedString;
    int startIndex = 0;
    int endIndex = 0;
    while ((endIndex = stringToBeSplitted.find(delimeter, startIndex))
           < stringToBeSplitted.size()) {
        string val = stringToBeSplitted.substr(startIndex, endIndex - startIndex);
        splittedString.push_back(val);
        startIndex = endIndex + delimeter.size();
    }
    if (startIndex < stringToBeSplitted.size()) {
        string val = stringToBeSplitted.substr(startIndex);
        splittedString.push_back(val);
    }
    return splittedString;
}

/**
 * Print to output file specified by outFileName
 * @param outFileName
 * @param vec
 */
void printISA(char *outFileName, vector<string> &vec) {
    ofstream outFile;
    outFile.open(outFileName);
    for (auto &it : vec) {
        outFile << it;
    }
    outFile.close();
}

/**
 * split the line by delimiter
 * @param s
 * @param delimiter
 * @return split vector of tokens
 */
deque<string> split(const string &s) {
    deque<string> tokens;
    //reference : https://stackoverflow.com/questions/49201654/splitting-a-string-with-multiple-delimiters-in-c
    std::regex words_regex("[^\\s=:%<>]+");
    auto words_begin = std::sregex_iterator(s.begin(), s.end(), words_regex);
    auto words_end = std::sregex_iterator();

    for (std::sregex_iterator i = words_begin; i != words_end; ++i)
        if (!((*i).str() == "//")) {
            if ((*i).str() != "x")
                tokens.push_back((*i).str());
        } else {
            break;
        }

    return tokens;
}

/**
 * print vector
 */
void print_vector(deque<string> a) {
    deque<string>::iterator it;
    for (it = a.begin(); it != a.end(); ++it) {
        cout << *it << " ";
    }
}
